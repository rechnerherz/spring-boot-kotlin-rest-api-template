package at.rechnerherz.example.domain.base

import at.rechnerherz.example.domain.account.Account
import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonProperty
import com.vladmihalcea.hibernate.type.json.JsonStringType
import org.hibernate.Hibernate
import org.hibernate.annotations.TypeDef
import org.hibernate.annotations.TypeDefs
import org.hibernate.proxy.HibernateProxy
import org.jadira.usertype.moneyandcurrency.moneta.PersistentCurrencyUnit
import org.jadira.usertype.moneyandcurrency.moneta.PersistentMoneyAmountAndCurrency
import org.javamoney.moneta.Money
import org.springframework.data.annotation.*
import org.springframework.data.annotation.AccessType
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.Instant
import javax.money.CurrencyUnit
import javax.persistence.*
import javax.persistence.Version
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1

/**
 * A base class for all entities (except for join table entities with composite keys).
 *
 * [POJO Models](http://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#entity-pojo),
 * [Optimistic](http://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#locking-optimistic),
 * [Auditing](https://docs.spring.io/spring-data/commons/docs/current/reference/html/#auditing)
 */
@MappedSuperclass
@EntityListeners(value = [AuditingEntityListener::class])
@TypeDefs(
    TypeDef(name = "Money", typeClass = PersistentMoneyAmountAndCurrency::class, defaultForType = Money::class),
    TypeDef(name = "CurrencyUnit", typeClass = PersistentCurrencyUnit::class, defaultForType = CurrencyUnit::class),
    TypeDef(name = "JSON", typeClass = JsonStringType::class)
)
abstract class BaseEntity : EqualsHashCodeAndToString() {

    companion object {
        private val toStringProperties: List<KProperty1<out Any, Any?>> = listOf(BaseEntity::id)
    }

    override val toStringProperties
        get() = BaseEntity.toStringProperties

    /**
     * The primary key.
     */
    abstract var id: Long?

    /**
     * Version number, generated by JPA/Hibernate, used for optimistic locking and returned as ETag header.
     *
     * The property access is necessary to avoid a bug(?) where the version would not be correctly obtained from a Hibernate proxy.
     */
    @Version
    @Column(name = "version", nullable = false)
    @JsonIgnore
    @AccessType(value = AccessType.Type.PROPERTY)
    var versionNumber: Long = 0

    /**
     * Alias for [versionNumber] to expose it.
     */
    val version: Long
        get() = versionNumber

    /**
     * Created at date.
     *
     * Set by the [AuditingEntityListener].
     */
    @CreatedDate
    @Column(nullable = false, updatable = false)
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    @ReadOnlyProperty
    var createdAt: Instant = Instant.now()

    /**
     * Created by account.
     *
     * Set by the [AuditingEntityListener] to the account provided by [at.rechnerherz.example.config.JpaConfig.accountAuditor].
     */
    @CreatedBy
    @ManyToOne(fetch = FetchType.LAZY)
    @JsonIgnore
    var createdBy: Account? = null

    /**
     * Last modified at date.
     *
     * Set by the [AuditingEntityListener].
     */
    @LastModifiedDate
    @Column(nullable = false)
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    var modifiedAt: Instant = Instant.now()

    /**
     * Last modified by account.
     *
     * Set by the [AuditingEntityListener] to the account provided by [at.rechnerherz.example.config.JpaConfig.accountAuditor].
     */
    @LastModifiedBy
    @ManyToOne(fetch = FetchType.LAZY)
    @JsonIgnore
    var modifiedBy: Account? = null

    /**
     * Whether the entity is active.
     *
     * Inactive accounts cannot log in.
     */
    var active: Boolean = true

    /**
     * Delete until date to comply with data protection regulations.
     */
    var deleteUntil: Instant? = null

    /**
     * The simple class name of the entity.
     */
    val className: String
        get() = javaClass.simpleName

    /**
     * If this is a lazy-loaded proxy, get the id without initializing it.
     */
    val lazyId: Long?
        @JsonIgnore
        get(): Long? = if (this is HibernateProxy) hibernateLazyInitializer.identifier as Long else id

    /**
     * All entity classes must define a short uppercase string that uniquely identities the entity class.
     */
    @get:JsonIgnore
    abstract val abbreviation: String

    /**
     * The identifier is the abbreviation followed by the id padded with zero to at least 6 digits.
     */
    val identifier: String
        get() = if (id == null) "" else "$abbreviation${String.format("%06d", id)}"
}

/**
 * If the entity is a lazy-loaded proxy, return the underlying implementation object, initializing it if necessary.
 */
inline fun <reified T : BaseEntity?> unproxy(entity: T): T =
    Hibernate.unproxy(entity) as T

/**
 * If the entity is a lazy-loaded proxy, return the underlying implementation class, initializing it if necessary.
 */
@Suppress("UNCHECKED_CAST")
inline fun <reified T : BaseEntity> getImplementationClass(entity: T): KClass<T> =
    Hibernate.getClass(entity).kotlin as KClass<T>

/**
 * Compare entities by id without initializing them. Only returns true if both entities are not null and their id is the same.
 */
infix fun <T : BaseEntity> T?.equalsById(that: T?): Boolean =
    this != null && that != null && lazyId == that.lazyId
